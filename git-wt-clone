#!/bin/bash

# git-wt-clone
#   by Steven Elliott
#
# Clone in a way that is suitable for git worktrees. The goal is to produce a
# directory named after the indicated repository, similar to the way git clone
# normally behaves, that contains a bare .git directory, with no checked out
# files. In that directory, or in the .git directory, worktrees may be created
# with a clean separation between user files, and git files. For example:
#   git worktree add master
# Initially there will be no local branches, so the new worktree will track
# a branch by the same name on the remote if it exists.
#
# Examples:
#  Clone into a directory that matches the repository specified:
#    git-wt-clone git@some-host.com:my-repo.git
#  Create multiple worktrees on clone:
#    git-wt-clone -b main -b dev git@some-host.com:my-repo.git
#  Clone without creating any worktrees:
#    git-wt-clone -n git@some-host.com:my-repo.git

die() {
    echo "git-wt-clone: $*" >&2
    exit 1
}

if [[ $# -lt 1 ]]
then
    die "usage: git wt-clone [-b <branch>]... [-n] [clone-options] <repo>"
fi

repo="${!#}"
args=("${@:1:$#-1}")
branches=()
no_worktrees=0
clone_opts=()
for ((i=0; i<${#args[@]}; i++))
do
    arg="${args[i]}"
    if [[ "$arg" == "--" ]]
    then
        clone_opts+=("${args[@]:i}")
        break
    elif [[ "$arg" == "-b" || "$arg" == "--branch" ]]
    then
        ((i++))
        branch="${args[i]}"
        if [[ -z "$branch" ]]
        then
            die "missing branch for $arg"
        fi
        branches+=("$branch")
    elif [[ "$arg" == "-n" || "$arg" == "--no-checkout" ]]
    then
        no_worktrees=1
    else
        clone_opts+=("$arg")
    fi
done
if [[ $no_worktrees -eq 1 && ${#branches[@]} -gt 0 ]]
then
    die "cannot combine -n with -b"
fi

repo_leaf="${repo##*/}"
repo_leaf="${repo_leaf%/}"
if [[ "$repo" == *:* && "$repo" != */* ]]
then
    repo_leaf="${repo_leaf##*:}"
fi
dir="${repo_leaf%.git}"
if [[ -z "$dir" ]]
then
    die "could not determine target directory from repo '$repo'"
fi

if [[ -e "$dir" ]]
then
    die "target directory '$dir' already exists"
fi

mkdir "$dir" || die "failed to create directory '$dir'"
cd "$dir" || die "failed to enter directory '$dir'"
git clone --bare --single-branch \
  --config remote.origin.fetch="+refs/heads/*:refs/remotes/origin/*" \
  "${clone_opts[@]}" \
  "$repo" .git || die "git clone failed"

current_branch="$(git symbolic-ref --quiet --short HEAD)"
default_branch="$current_branch"
if [[ -n "$current_branch" ]]
then
    # Remove the default local branch so worktrees start from remote branches.
    git branch -D "$current_branch" || die "failed to delete branch '$current_branch'"
fi

git fetch || die "git fetch failed"

if [[ $no_worktrees -eq 0 ]]
then
    if [[ ${#branches[@]} -eq 0 ]]
    then
        if [[ -z "$default_branch" ]]
        then
            die "no default branch; use -b or -n"
        fi
        branches=("$default_branch")
    fi
    for branch in "${branches[@]}"
    do
        git worktree add --guess-remote "$branch" || die "failed to add worktree '$branch'"
    done
fi
